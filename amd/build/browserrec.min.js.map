{"version":3,"file":"browserrec.min.js","sources":["../src/browserrec.js"],"sourcesContent":["/* jshint ignore:start */\ndefine(['jquery', 'core/log'], function ($, log) {\n\n    \"use strict\"; // jshint ;_;\n\n    log.debug('qtype_aitext browser speech rec: initialising');\n\n    return {\n\n        recognition: null,\n        recognizing: false,\n        final_transcript: '',\n        interim_transcript: '',\n        start_timestamp: 0,\n        lang: 'en-US',\n        interval: 0,\n\n\n        //for making multiple instances\n        clone: function () {\n            return $.extend(true, {}, this);\n        },\n\n        will_work_ok: function(opts){\n            //Edge and Safari both have browser recognition, but it's not good enough and we need to test it better (2021-11-21)\n            var brave = typeof navigator.brave !== 'undefined';\n            if(brave){return false;}\n\n            var edge = navigator.userAgent.toLowerCase().indexOf(\"edg/\") > -1;\n            if(edge){return false;}\n\n            var has_chrome = navigator.userAgent.indexOf('Chrome') > -1;\n            var has_safari = navigator.userAgent.indexOf(\"Safari\") > -1;\n            var safari = has_safari && !has_chrome;\n            if(safari){return false;}\n\n            //This is feature detection, and for chrome its ok. the others might say they do speech rec, but its hard to be sure\n            return ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window);\n\n        },\n\n        init: function (lang,waveheight,uniqueid) {\n            log.debug('bh : ' + uniqueid);\n            var SpeechRecognition = SpeechRecognition || webkitSpeechRecognition;\n            this.recognition = new SpeechRecognition();\n            this.recognition.continuous = true;\n            this.recognition.interimResults = true;\n            this.lang = lang;\n            this.waveHeight = waveheight;\n            this.uniqueid = uniqueid;\n            this.prepare_html();\n            this.register_events();\n        },\n\n        prepare_html: function(){\n            this.canvas =$('.' + this.uniqueid + \"_waveform\");\n            this.canvasCtx = this.canvas[0].getContext(\"2d\");\n        },\n\n        set_grammar: function (grammar) {\n            var SpeechGrammarList = SpeechGrammarList || webkitSpeechGrammarList;\n            if (SpeechGrammarList) {\n                var speechRecognitionList = new SpeechGrammarList();\n                speechRecognitionList.addFromString(grammar, 1);\n                this.recognition.grammars = speechRecognitionList;\n            }\n        },\n\n        start: function () {\n            var that =this;\n\n            //If we already started ignore this\n            if (this.recognizing) {\n                return;\n            }\n            this.recognizing = true;\n            this.final_transcript = '';\n            this.interim_transcript = '';\n            this.recognition.lang = this.lang;//select_dialect.value;\n            this.recognition.start();\n            this.start_timestamp = Date.now();//event.timeStamp;\n            that.onstart();\n\n\n            //kick off animation\n            that.interval = setInterval(function() {\n                that.drawWave();\n            }, 100);\n        },\n\n        stop: function () {\n            var that=this;\n            this.recognizing = false;\n            this.recognition.stop();\n            clearInterval(this.interval);\n            this.canvasCtx.clearRect(0, 0, this.canvas.width()*2, this.waveHeight * 2);\n            setTimeout(function() {\n                that.onfinalspeechcapture(that.final_transcript);\n            }, 1000);\n            this.onend();\n        },\n\n        register_events: function () {\n\n            var recognition = this.recognition;\n            var that = this;\n\n            recognition.onerror = function (event) {\n                if (event.error == 'no-speech') {\n                    log.debug('info_no_speech');\n                }\n                if (event.error == 'audio-capture') {\n                    log.debug('info_no_microphone');\n                }\n                if (event.error == 'not-allowed') {\n                    if (event.timeStamp - that.start_timestamp < 100) {\n                        log.debug('info_blocked');\n                    } else {\n                        log.debug('info_denied');\n                    }\n                }\n                that.onerror({error: {name: event.error}});\n            };\n\n            recognition.onend = function () {\n                if(that.recognizing){\n                    that.recognition.start();\n                }\n\n            };\n\n            recognition.onresult = function (event) {\n                for (var i = event.resultIndex; i < event.results.length; ++i) {\n                    if (event.results[i].isFinal) {\n                        that.final_transcript += event.results[i][0].transcript;\n                    } else {\n                        var provisional_transcript = that.final_transcript + event.results[i][0].transcript;\n                        //the interim and final events do not arrive in sequence, we dont want the length going down, its weird\n                        //so just dont respond when the sequence is wonky\n                        if(provisional_transcript.length < that.interim_transcript.length){\n                            return;\n                        }else{\n                            that.interim_transcript = provisional_transcript;\n                        }\n                        that.oninterimspeechcapture(that.interim_transcript);\n                    }\n                }\n\n            };\n        },//end of register events\n\n        drawWave: function() {\n\n            var width = this.canvas.width() * 2;\n            var bufferLength=4096;\n\n            this.canvasCtx.fillStyle = 'white';\n            this.canvasCtx.fillRect(0, 0, width, this.waveHeight*2);\n\n            this.canvasCtx.lineWidth = 5;\n            this.canvasCtx.strokeStyle = 'gray';\n            this.canvasCtx.beginPath();\n\n            var slicewaveWidth = width / bufferLength;\n            var x = 0;\n\n            for (var i = 0; i < bufferLength; i++) {\n\n                var v = ((Math.random() * 64) + 96) / 128.0;\n                var y = v * this.waveHeight;\n\n                if (i === 0) {\n                    // this.canvasCtx.moveTo(x, y);\n                } else {\n                    this.canvasCtx.lineTo(x, y);\n                }\n                x += slicewaveWidth;\n            }\n\n            this.canvasCtx.lineTo(width, this.waveHeight);\n            this.canvasCtx.stroke();\n\n        },\n\n        onstart: function () {\n            log.debug('started');\n        },\n        onerror: function () {\n            log.debug('error');\n        },\n        onend: function () {\n            log.debug('end');\n        },\n        onfinalspeechcapture: function (speechtext) {\n            log.debug(speechtext);\n        },\n        oninterimspeechcapture: function (speechtext) {\n            // log.debug(speechtext);\n        }\n\n    };//end of returned object\n});//total end\n"],"names":["define","$","log","debug","recognition","recognizing","final_transcript","interim_transcript","start_timestamp","lang","interval","clone","extend","this","will_work_ok","opts","navigator","brave","userAgent","toLowerCase","indexOf","has_chrome","window","init","waveheight","uniqueid","SpeechRecognition","webkitSpeechRecognition","continuous","interimResults","waveHeight","prepare_html","register_events","canvas","canvasCtx","getContext","set_grammar","grammar","SpeechGrammarList","webkitSpeechGrammarList","speechRecognitionList","addFromString","grammars","start","that","Date","now","onstart","setInterval","drawWave","stop","clearInterval","clearRect","width","setTimeout","onfinalspeechcapture","onend","onerror","event","error","timeStamp","name","onresult","i","resultIndex","results","length","isFinal","transcript","provisional_transcript","oninterimspeechcapture","fillStyle","fillRect","lineWidth","strokeStyle","beginPath","slicewaveWidth","x","y","Math","random","lineTo","stroke","speechtext"],"mappings":"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"}